---
title: "Southwest Social Networks"
author: "Nick Gauthier"
output:
  pdf_document: 
    keep_tex: yes
  html_document: 
    fig_height: 10
    fig_width: 10
    keep_md: yes
---
# Data import

First import the SWSN attribute file. Use tidyverse packages for data munging.

Site coordinates are in UTM, so first use rgdal to reproject to LatLon.
```{r message = F, warning = F}
library(tidyverse)
library(rgdal)
library(igraph)
```

Import the SWSN attribute file and reproject the UTM coordinates to Lat-Lon.
```{r}
swsn.attr <- read_csv('Data/attributes_orig.csv') %>%
  select(-1) # drop ID column

swsn.attr <-  swsn.attr %>% 
  select(lon = EASTING, lat = NORTHING) %>%
  SpatialPoints(proj4string=CRS("+proj=utm +zone=12 +datum=WGS84")) %>%
  spTransform(CRS("+proj=longlat +datum=WGS84")) %>% 
  coordinates %>%
  data.frame %>%
  cbind(swsn.attr, .)

glimpse(swsn.attr)
```


Now define a function to import the SWSN adjacency matrix for a given time step. This function imports the adjacency matrix, keeps only those connections with >= 75% similarity, and creates an igraph object. Then it adds attribute data from above to the graph object.
```{r message = F}
  # we use a hack here to set the vertex attributes. need to find if there's another way to easily add a whole dataframe of vertex attributes using something other than graph_from_data_frame's vertices arguement
readSWSN <- function(net){
  read.csv(net, row.names = 1, check.names = F)  %>%
    as.matrix %>%
    graph_from_adjacency_matrix(mode = 'undirected', weighted = T, diag = F) %>%
    as_data_frame %>%
    graph_from_data_frame(directed = F, vertices = swsn.attr)
}
```

Use the function to import the network datasets.
```{r}
ad1200 <- readSWSN('Data/AD1200sim.csv')
ad1250 <- readSWSN('Data/AD1250sim.csv')
ad1300 <- readSWSN('Data/AD1300sim.csv')
ad1350 <- readSWSN('Data/AD1350sim.csv')
ad1400 <- readSWSN('Data/AD1400sim.csv')
```


## More Minimal network maps

```{r}
library(GGally)
library(ggmap)
library(maps)
library(raster)
library(maptools)

states <- map('state', regions = c('arizona', 'new mexico'), fill = T, plot = F)
IDs <- sapply(strsplit(states$names, ":"), function(x) x[1])
states.ply <- map2SpatialPolygons(states, IDs=IDs)



base <- ggplot(data = states) +
  geom_polygon(aes(x = long, y = lat, group = region), color = 'black', fill = 'white') +
  coord_quickmap() +
  theme_minimal() +
  labs(x = "Longitude", y = "Latitude")

n1 <- ggnetworkmap(base, ad1200, great.circles = T, size = .5, segment.alpha = I(.5)) +
  geom_label(x = -106, y = 35, label = 'AD 1200')

n2 <- ggnetworkmap(base, ad1250, great.circles = T, size = .5, segment.alpha = I(.5)) +
  geom_label(x = -106, y = 35, label = 'AD 1250')

n3 <- ggnetworkmap(base, ad1300, great.circles = T, size = .5, segment.alpha = I(.5)) +
  geom_label(x = -106, y = 35, label = 'AD 1300')

n4 <- ggnetworkmap(base, ad1350, great.circles = T, size = .5, segment.alpha = I(.5)) +
  geom_label(x = -106, y = 35, label = 'AD 1350')

n5 <- ggnetworkmap(base, ad1400, great.circles = T, size = .5, segment.alpha = I(.5)) +
  geom_label(x = -106, y = 35, label = 'AD 1400')

plotEOF <- function(x){
  rasterVis::gplot(x) +
  geom_raster(aes(fill = value), na.rm = T, show.legend = F) +
  scale_fill_distiller(palette = 'RdBu', na.value = NA) +
  geom_polygon(data = states, aes(x = long, y = lat, group = region), color = 'black', fill = NA) +
  coord_quickmap() +
  theme_minimal() +
  labs(x = "Longitude", y = "Latitude")
}

eof1200 <- brick('Data/eof1200.nc')[[3]] %>%
  mask(states.ply) %>% 
  plotEOF
  

e1 <- ggnetworkmap(eof1200, ad1200, great.circles = T, size = .5, segment.alpha = I(.5)) #+ geom_label(x = -106, y = 35, label = 'AD 1200')

  
eof1250 <- brick('Data/eof1250.nc')[[3]] %>%
  mask(states.ply) %>%
    plotEOF


e2 <- ggnetworkmap(eof1250, ad1250, great.circles = T, size = .5, segment.alpha = I(.5)) #+  geom_label(x = -106, y = 35, label = 'AD 1250')

eof1300 <- brick('Data/eof1300.nc')[[3]] %>%
  mask(states.ply) %>%
    plotEOF

e3 <- ggnetworkmap(eof1300, ad1300, great.circles = T, size = .5, segment.alpha = I(.5))# + geom_label(x = -106, y = 35, label = 'AD 1300')

eof1350 <- brick('Data/eof1350.nc')[[3]] %>%
  mask(states.ply) %>%
    plotEOF

e4 <- ggnetworkmap(eof1350, ad1350, great.circles = T, size = .5, segment.alpha = I(.5)) #+ geom_label(x = -106, y = 35, label = 'AD 1350')

eof1400 <- brick('Data/eof1400.nc')[[3]] %>%
  mask(states.ply) %>%
    plotEOF

e5 <- ggnetworkmap(eof1400, ad1400, great.circles = T, size = .5, segment.alpha = I(.5)) #+ geom_label(x = -106, y = 35, label = 'AD 1400')
```
Get basemap for elevation.
```{r eval=FALSE, include=FALSE, cache=T}
# courtesy R Lovelace

states.ply <- map('state', region = c('arizona', 'new mexico'), fill = T, plot = F)
IDs <- sapply(strsplit(states.ply$names, ":"), function(x) x[1])
states.ply <- map2SpatialPolygons(states.ply, IDs=IDs)

ggmap_rast <- function(map){
  map_bbox <- attr(map, 'bb') 
  .extent <- extent(as.numeric(map_bbox[c(2,4,1,3)]))
  my_map <- raster(.extent, nrow= nrow(map), ncol = ncol(map))
  rgb_cols <- setNames(as.data.frame(t(col2rgb(map))), c('red','green','blue'))
  red <- my_map
  values(red) <- rgb_cols[['red']]
  green <- my_map
  values(green) <- rgb_cols[['green']]
  blue <- my_map
  values(blue) <- rgb_cols[['blue']]
  stack(red,green,blue)
}


ggplot_build(n1)$layout$panel_ranges[[1]]$x.range 
ggplot_build(n2)$layout$panel_ranges[[1]]$y.range
terrain.background <- get_map(location = c(left = -115.3997, right = -102.4102, bottom = 31.06377, top = 37.28437),
  zoom = 8,
  color = "bw",
  source = "stamen",
  maptype = "terrain-background")

terrain.rast <- ggmap_rast(map = terrain.background) # convert stamen map to raster object
state.only <- mask(terrain.rast, states.ply) # clip to bounds of census tracts


# prep raster as a data frame for printing with ggplot
sw.df <- data.frame(rasterToPoints(state.only))
m1 <- ggplot(sw.df) + 
  geom_point(aes(x=x, y=y, col=rgb(layer.1/255, layer.2/255, layer.3/255))) + 
  scale_color_identity() +
  geom_polygon(data = states, aes(x = long, y = lat, group = region), color = 'black', fill = NA) +
  coord_quickmap() +
  geom_point(aes(x = easting, y = northing), size = 1, data = swsn.pts) +
  theme_nothing()
```



```{r, include=FALSE}
#from rcookbook
# Multiple plot function
#
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                    ncol = cols, nrow = ceiling(numPlots/cols))
  }

 if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}
```

```{r}
#multiplot(n1, n2, n3, n4, layout = matrix(c(1,2,3,4), byrow = T, nrow = 2))
multiplot(e1, e2, e3, e4, layout = matrix(c(1,2,3,4), byrow = T, nrow = 2))

#multiplot(n1, n2, n3, n4, n5, m1, layout = matrix(c(1,2,3,4,5,6), byrow = T, nrow = 3))
#multiplot(e1, e2, e3, e4, e5, layout = matrix(c(1,2,3,4,5,6), byrow = T, nrow = 3))

```

eof1200 <- brick('Data/eof1200.nc')[[4]] %>%
  mask(states.ply) %>% 
  plotEOF
  
e1 <- ggnetworkmap(eof1200, ad1200, great.circles = T, size = .5, segment.alpha = I(.5)) + geom_label(x = -106, y = 35, label = 'AD 1200')

eof1250 <- brick('Data/eof1250.nc')[[4]] %>%
  mask(states.ply) %>%
    plotEOF

e2 <- ggnetworkmap(eof1250, ad1250, great.circles = T, size = .5, segment.alpha = I(.5)) +  geom_label(x = -106, y = 35, label = 'AD 1250')

eof1300 <- brick('Data/eof1300.nc')[[4]] %>%
  mask(states.ply) %>%
    plotEOF

e3 <- ggnetworkmap(eof1300, ad1300, great.circles = T, size = .5, segment.alpha = I(.5)) + geom_label(x = -106, y = 35, label = 'AD 1300')

eof1350 <- brick('Data/eof1350.nc')[[4]] %>%
  mask(states.ply) %>%
    plotEOF

multiplot(e1, e2, e3, e4, layout = matrix(c(1,2,3,4), byrow = T, nrow = 2))



