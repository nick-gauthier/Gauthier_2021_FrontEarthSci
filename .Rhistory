filter(distances, weight > 0 & weight < 1) %>%
ggplot(aes(distance, weight)) +
geom_point(alpha = .1) +
geom_line(aes(y = predict(test, type = 'response')), color = 'red') +
geom_line(aes(y = predict(test2, type = 'response'))) +
geom_line(aes(y = predict(test3, type = 'response'))) +
# geom_smooth(method = 'gam', formula = y ~ s(x, bs = 'cr'), method.args = list(family = "betar"))  +
#geom_smooth(method = 'gam', formula = y ~ s(x), method.args = list(family = "betar"), color = 'grey')  +
# geom_smooth(color = 'red')  +
# geom_smooth(method = 'gam', method.args = list(family = gaussian(link = 'log')), color = 'red') +
#  geom_smooth(method = 'glm', method.args = list(family = gaussian(link = 'log')), color = 'green') +
#  geom_smooth(method = 'glm', formula = y ~ I(log(x)), method.args = list(family = gaussian(link = 'log')), color = 'orange') +
geom_smooth(method = 'glm', formula = y ~ I(log(x) + x), method.args = list(family = gaussian(link = 'log')), color = 'yellow') +
scale_y_continuous(limits = c(0, 1))
filter(distances, weight > 0 & weight < 1) %>%
ggplot(aes(distance, weight)) +
geom_point(alpha = .1) +
geom_hex() +
geom_line(aes(y = predict(test, type = 'response')), color = 'red') +
geom_line(aes(y = predict(test2, type = 'response'))) +
geom_line(aes(y = predict(test3, type = 'response'))) +
# geom_smooth(method = 'gam', formula = y ~ s(x, bs = 'cr'), method.args = list(family = "betar"))  +
#geom_smooth(method = 'gam', formula = y ~ s(x), method.args = list(family = "betar"), color = 'grey')  +
# geom_smooth(color = 'red')  +
# geom_smooth(method = 'gam', method.args = list(family = gaussian(link = 'log')), color = 'red') +
#  geom_smooth(method = 'glm', method.args = list(family = gaussian(link = 'log')), color = 'green') +
#  geom_smooth(method = 'glm', formula = y ~ I(log(x)), method.args = list(family = gaussian(link = 'log')), color = 'orange') +
geom_smooth(method = 'glm', formula = y ~ I(log(x) + x), method.args = list(family = gaussian(link = 'log')), color = 'yellow') +
scale_y_continuous(limits = c(0, 1))
filter(distances, weight > 0 & weight < 1) %>%
ggplot(aes(distance, weight)) +
geom_point(alpha = .1) +
geom_hex() +
geom_line(aes(y = predict(test, type = 'response')), color = 'red') +
geom_line(aes(y = predict(test2, type = 'response')), color = 'white') +
geom_line(aes(y = predict(test3, type = 'response'))) +
# geom_smooth(method = 'gam', formula = y ~ s(x, bs = 'cr'), method.args = list(family = "betar"))  +
#geom_smooth(method = 'gam', formula = y ~ s(x), method.args = list(family = "betar"), color = 'grey')  +
# geom_smooth(color = 'red')  +
# geom_smooth(method = 'gam', method.args = list(family = gaussian(link = 'log')), color = 'red') +
#  geom_smooth(method = 'glm', method.args = list(family = gaussian(link = 'log')), color = 'green') +
#  geom_smooth(method = 'glm', formula = y ~ I(log(x)), method.args = list(family = gaussian(link = 'log')), color = 'orange') +
geom_smooth(method = 'glm', formula = y ~ I(log(x) + x), method.args = list(family = gaussian(link = 'log')), color = 'yellow') +
scale_y_continuous(limits = c(0, 1))
knitr::opts_chunk$set(tidy = FALSE, message = FALSE, warning = FALSE, cache=TRUE)
distances <- readRDS('distances.rds')
distances
distances %>%
group_by(from) %>%
arrange(distance)
distances %>%
group_by(from) %>%
arrange(from, distance)
distances %>%
group_by(from) %>%
top_n(10, distance)
distances %>%
group_by(from) %>%
top_n(-10, distance)
distances %>%
group_by(from) %>%
arrange(from_distance)
distances %>%
group_by(from) %>%
arrange(from,distance)
distances %>%
group_by(from) %>%
top_n(-10, distance)
r <- raster(nrows=6, ncols=7, xmn=0, xmx=7, ymn=0, ymx=6, crs="+proj=utm +units=m")
r[] <- c(2, 2, 1, 1, 5, 5, 5,
2, 2, 8, 8, 5, 2, 1,
7, 1, 1, 8, 2, 2, 2,
8, 7, 8, 8, 8, 8, 5,
8, 8, 1, 1, 5, 3, 9,
8, 1, 1, 2, 5, 3, 9)
T <- transition(r, function(x) 1/mean(x), 8)
# 1/mean: reciprocal to get permeability
T <- geoCorrection(T)
c1 <- c(5.5,1.5)
c2 <- c(1.5,5.5)
#make a SpatialLines object for visualization
sPath1 <- shortestPath(T, c1, c2, output="SpatialLines")
plot(r)
lines(sPath1)
plot(r)
lines(sPath1)
#make a TransitionLayer for further calculations
sPath2 <- shortestPath(T, c1, c2)
plot(raster(sPath2))
c2 <- c(1.5,5.5, 2, 6)
#make a SpatialLines object for visualization
sPath1 <- shortestPath(T, c1, c2, output="SpatialLines")
c1 <- c(5.5,1.5, 3, 4)
c2 <- c(1.5,5.5, 2, 6)
cbind(c1, c2)
#make a SpatialLines object for visualization
sPath1 <- shortestPath(T, c1, cbind(c1, c2), output="SpatialLines")
cbind(c1, c2)
#make a SpatialLines object for visualization
sPath1 <- shortestPath(T, cbind(c1, c2), output="SpatialLines")
c3 <- cbind(c1, c2)
c3[1]
c3[1,]
#make a SpatialLines object for visualization
sPath1 <- shortestPath(T, c3[1,], c3[2:4,] output="SpatialLines")
#make a SpatialLines object for visualization
sPath1 <- shortestPath(T, c3[1,], c3[2:4,], output="SpatialLines")
plot(r)
lines(sPath1)
plot(r)
lines(sPath1)
sPath1
gc()
knitr::opts_chunk$set(tidy = FALSE, message = FALSE, warning = FALSE, cache=TRUE)
library(raster) # raster data manipulation
library(tidyverse) # data analysis and plotting
library(rgdal) # reprojection of spatial points
library(gdistance) # least cost distance calculations
library(wql) # empirical orthogonal function calculation
library(tidygraph) # network analysis
library(ggraph) # network plotting
library(mgcv) # GAM fitting
library(mgcViz) # GAM plotting
library(dismo)
theme_set(theme_bw())
node_data <- read_csv('data/attributes_orig.csv') %>%
select(-c(SWSN_ID,GKPM:Periods, N0S1))
read_swsn <- function(net, time){
read.csv(net, row.names = 1, check.names = FALSE) %>%
as.matrix %>%
replace(. == 0, 999) %>%
as_tbl_graph(directed = TRUE) %E>%
mutate(weight = if_else(weight == 999, 0, weight)) %>%
rename(similarity = weight) %>%
filter(!edge_is_loop()) %N>%
mutate(centrality = centrality_eigen(weights = similarity)) %E>%
mutate(time = 1150 + 50 * time,
centrality_from = .N()$centrality[from],
centrality_to = .N()$centrality[to]) %N>%
select(-centrality)
}
swsn <- list.files('data/Sim', full.names = TRUE) %>%
imap(read_swsn) %>%
reduce(graph_join, by = 'name') %>%
left_join(node_data, by = c('name' = 'SWSN_Site'))
pts <- swsn %N>%
select(x = EASTING, y = NORTHING) %>%
as_tibble %>%
SpatialPoints(proj4string=CRS("+proj=utm +zone=12 +datum=NAD27")) %>%
spTransform(CRS("+proj=longlat +datum=WGS84")) %>%
coordinates %>%
data.frame
swsn
states <- maps::map('state', regions = c('arizona', 'new mexico'), fill = TRUE, plot = FALSE)
swsn %E>%
arrange(similarity) %>%
ggraph('manual', node.positions = pts) +
geom_edge_fan(aes(alpha = similarity, color = similarity)) +
geom_polygon(data = states, aes(x = long, y = lat, group = region), color = 'black', fill = NA) +
geom_node_point() +#aes(size = centrality, color = centrality)) +
facet_edges(~time) +
scale_edge_alpha() +
coord_equal() +
theme_graph()
elev <- raster('~/Downloads/SRTM_W_250m_TIF/SRTM_W_250m.tif') %>%
crop(bbox)
bbox <- extent(c(-113.5, -106.5, 31, 37.5))
elev <- raster('~/Downloads/SRTM_W_250m_TIF/SRTM_W_250m.tif') %>%
crop(bbox)
library(rayshader)
#And convert it to a matrix:
elmat =  matrix(raster::extract(aggregate(elev, fact = 4),raster::extent(aggregate(elev, fact = 4)),buffer=1000),
nrow=ncol(aggregate(elev, fact = 4)),ncol=nrow(aggregate(elev, fact = 4)))
#We use another one of rayshader's built-in textures:
elmat %>%
sphere_shade(texture = "desert") %>%
plot_map()
#We use another one of rayshader's built-in textures:
elmat %>%
sphere_shade(texture = "desert", zscale = 3) %>%
plot_map()
elmat %>%
sphere_shade(texture = "desert") %>%
add_shadow(ray_shade(elmat)) %>%
add_shadow(ambient_shade(elmat)) %>%
plot_3d(elmat)
#We use another one of rayshader's built-in textures:
elmat %>%
sphere_shade(texture = "desert", zscale = 10) %>%
plot_map()
#We use another one of rayshader's built-in textures:
elmat %>%
sphere_shade(texture = "desert", zscale = 100) %>%
plot_map()
#We use another one of rayshader's built-in textures:
elmat %>%
sphere_shade(texture = "desert", zscale = 50) %>%
plot_map()
#We use another one of rayshader's built-in textures:
elmat %>%
sphere_shade(texture = "desert", zscale = 20) %>%
plot_map()
#And convert it to a matrix:
elmat =  matrix(raster::extract(aggregate(elev, fact = 2),raster::extent(aggregate(elev, fact = 2)),buffer=1000),
nrow=ncol(aggregate(elev, fact = 2)),ncol=nrow(aggregate(elev, fact = 2)))
#And convert it to a matrix:
elmat =  matrix(raster::extract(aggregate(elev, fact = 2),raster::extent(aggregate(elev, fact = 2)),buffer=1000),
nrow=ncol(aggregate(elev, fact = 2)),ncol=nrow(aggregate(elev, fact = 2)))
#We use another one of rayshader's built-in textures:
elmat %>%
sphere_shade(texture = "desert", zscale = 20) %>%
plot_map()
#We use another one of rayshader's built-in textures:
elmat %>%
sphere_shade(texture = "desert", zscale = 10) %>%
plot_map()
#We use another one of rayshader's built-in textures:
elmat %>%
sphere_shade(texture = "inhof1", zscale = 10) %>%
plot_map()
#We use another one of rayshader's built-in textures:
elmat %>%
sphere_shade(texture = "imhof1", zscale = 10) %>%
plot_map()
#We use another one of rayshader's built-in textures:
elmat %>%
sphere_shade(texture = "imhof2", zscale = 10) %>%
plot_map()
#We use another one of rayshader's built-in textures:
elmat %>%
sphere_shade(texture = "imhof3", zscale = 10) %>%
plot_map()
#We use another one of rayshader's built-in textures:
elmat %>%
sphere_shade(texture = "imhof4", zscale = 10) %>%
plot_map()
#We use another one of rayshader's built-in textures:
elmat %>%
sphere_shade(texture = "bw", zscale = 10) %>%
plot_map()
#We use another one of rayshader's built-in textures:
elmat %>%
sphere_shade(texture = "unicorn", zscale = 10) %>%
plot_map()
#We use another one of rayshader's built-in textures:
elmat %>%
sphere_shade(texture = "inhof2", zscale = 10) %>%
plot_map()
#We use another one of rayshader's built-in textures:
elmat %>%
sphere_shade(texture = "imhof2", zscale = 10) %>%
plot_map()
#We use another one of rayshader's built-in textures:
elmat %>%
sphere_shade(texture = "imhof1", zscale = 10) %>%
plot_map()
#We use another one of rayshader's built-in textures:
elmat %>%
sphere_shade(texture = "imhof1", zscale = 1) %>%
plot_map()
#We use another one of rayshader's built-in textures:
elmat %>%
sphere_shade(texture = "imhof1", zscale = 10) %>%
plot_map()
elmat %>%
sphere_shade(texture = "imhof1", zscale = 10)
gc()
altDiff <- function(x){x[2] - x[1]}
hd <- transition(elev, altDiff, 8, symm = FALSE)
gc()
cell.targets <- Which(!is.na(elev), cells = TRUE)
adj <- adjacent(elev, cells = cell.targets, target = cell.targets, pairs = TRUE, directions = 8)
gc()
altDiff <- function(x){x[2] - x[1]}
gc()
slope_c <- geoCorrection(hd, type = 'c')
gc()
speed_c <- slope_c
rm(hd)
speed_c[adj] <- 6 * exp(-3.5 * abs(slope_c[adj] + 0.05))
rm(slope_c, adj)
gc()
conductance_c <- geoCorrection(speed_c, type = 'c')
rm(slope_c, adj, elev)
gc()
rm(hd, slope_c, adj, elev)
gc()
conductance_c <- geoCorrection(speed_c, type = 'c')
saveRDS(speed_c, 'speed.rds')
knitr::opts_chunk$set(tidy = FALSE, message = FALSE, warning = FALSE, cache=TRUE)
library(raster) # raster data manipulation
library(tidyverse) # data analysis and plotting
library(rgdal) # reprojection of spatial points
library(gdistance) # least cost distance calculations
library(wql) # empirical orthogonal function calculation
library(tidygraph) # network analysis
library(ggraph) # network plotting
library(mgcv) # GAM fitting
library(mgcViz) # GAM plotting
library(dismo)
speed_c <- readRDS('speed.rds')
conductance_c <- geoCorrection(speed_c, type = 'c')
saveRDS(conductance_c, 'conductance.RDS')
rm(elev, hd, slope_c, slope_r, adj, speed_c, speed_r)
gc()
conductance_c %>%
raster %>%
as.data.frame(xy = TRUE, na.rm = TRUE) %>%
ggplot(aes(x, y)) +
geom_raster(aes(fill = layer)) +
scale_fill_viridis_c() +
theme_void() +
coord_quickmap()
pts
theme_set(theme_bw())
node_data <- read_csv('data/attributes_orig.csv') %>%
select(-c(SWSN_ID,GKPM:Periods, N0S1))
read_swsn <- function(net, time){
read.csv(net, row.names = 1, check.names = FALSE) %>%
as.matrix %>%
replace(. == 0, 999) %>%
as_tbl_graph(directed = TRUE) %E>%
mutate(weight = if_else(weight == 999, 0, weight)) %>%
rename(similarity = weight) %>%
filter(!edge_is_loop()) %N>%
mutate(centrality = centrality_eigen(weights = similarity)) %E>%
mutate(time = 1150 + 50 * time,
centrality_from = .N()$centrality[from],
centrality_to = .N()$centrality[to]) %N>%
select(-centrality)
}
swsn <- list.files('data/Sim', full.names = TRUE) %>%
imap(read_swsn) %>%
reduce(graph_join, by = 'name') %>%
left_join(node_data, by = c('name' = 'SWSN_Site'))
pts <- swsn %N>%
select(x = EASTING, y = NORTHING) %>%
as_tibble %>%
SpatialPoints(proj4string=CRS("+proj=utm +zone=12 +datum=NAD27")) %>%
spTransform(CRS("+proj=longlat +datum=WGS84")) %>%
coordinates %>%
data.frame
pts
#make a SpatialLines object for visualization
sPath1 <- shortestPath(T, c3[1:2,], c3[3:4,], output="SpatialLines")
c3 <- cbind(c(5.5,1.5) ,c(1.5,5.5))
#make a SpatialLines object for visualization
sPath1 <- shortestPath(T, c3[1:2,], c3[3:4,], output="SpatialLines")
#make a SpatialLines object for visualization
sPath1 <- shortestPath(conductance_c, pts[1,], pts[2,], output="SpatialLines")
pts %>%
as.matrix %>%
sPath1 <- shortestPath(conductance_c, .[1,], .[2,], output="SpatialLines")
pts %>%
as.matrix %>%
shortestPath(conductance_c, .[1,], .[2,], output="SpatialLines")
distances %>%
group_by(from) %>%
top_n(-10, distance) # select the closest 10 neighbors to each site
distances <- readRDS('distances.rds')
distances %>%
group_by(from) %>%
top_n(-10, distance) # select the closest 10 neighbors to each site
distances %>%
group_by(from) %>%
top_n(-10, distance) %>%
nest# select the closest 10 neighbors to each site
distances %>%
group_by(from) %>%
top_n(-10, distance)
as.matrix(pts)
test <- shortestPath(conductance_c, as.matrix(pts)[1,], as.matrix(pts)[3,], output="SpatialLines")
elev <- raster('~/Downloads/SRTM_W_250m_TIF/SRTM_W_250m.tif') %>%
crop(bbox)
bbox <- extent(c(-113.5, -106.5, 31, 37.5))
elev <- raster('~/Downloads/SRTM_W_250m_TIF/SRTM_W_250m.tif') %>%
crop(bbox)
plot(elev)
lines(test)
test
distances %>%
group_by(from) %>%
top_n(-10, distance) %>% # select the closest 10 neighbors to each site
filter(from == 1)
distances %>%
group_by(from) %>%
top_n(-10, distance) %>% # select the closest 10 neighbors to each site
filter(from == 1) %>%
pull(to)
test <- shortestPath(conductance_c, as.matrix(pts)[1,], as.matrix(pts)[distances %>%
group_by(from) %>%
top_n(-10, distance) %>% # select the closest 10 neighbors to each site
filter(from == 1) %>%
pull(to),], output="SpatialLines")
plot(elev)
lines(test)
test <- shortestPath(conductance_c, as.matrix(pts)[2,], as.matrix(pts)[distances %>%
group_by(from) %>%
top_n(-10, distance) %>% # select the closest 10 neighbors to each site
filter(from == 2) %>%
pull(to),], output="SpatialLines")
plot(elev)
lines(test)
plot(crop(elev, extent(c(-112, -110, 32, 33))))
lines(test)
plot(crop(elev, extent(c(-111, -110, 32, 33))))
plot(crop(elev, extent(c(-111, -110, 32, 33))))
lines(test)
distances %>%
group_by(from) %>%
top_n(-10, distance) %>% # select the closest 10 neighbors to each site
select(-distance)
distances %>%
group_by(from) %>%
top_n(-10, distance) %>% # select the closest 10 neighbors to each site
select(-distance) %>%
nest
distances %>%
group_by(from) %>%
top_n(-10, distance) %>% # select the closest 10 neighbors to each site
select(-distance) %>%
summarise(from = c(from))
distances %>%
group_by(from) %>%
top_n(-10, distance) %>% # select the closest 10 neighbors to each site
select(-distance) %>%
summarise(to = c(to))
distances %>%
group_by(from) %>%
top_n(-10, distance) %>% # select the closest 10 neighbors to each site
select(-distance) %>%
nest %>%
mutate(to = map_dbl(to, ~c(.)))
distances %>%
group_by(from) %>%
top_n(-10, distance) %>% # select the closest 10 neighbors to each site
select(-distance) %>%
nest %>%
mutate(to = map_dbl(data, ~c(.)))
distances %>%
group_by(from) %>%
top_n(-10, distance) %>% # select the closest 10 neighbors to each site
select(-distance) %>%
nest %>%
mutate(to = map(data, ~c(.)))
distances %>%
group_by(from) %>%
top_n(-10, distance) %>% # select the closest 10 neighbors to each site
select(-distance) %>%
nest %>%
mutate(to = map(data, ~c(.))) %>%
pull(to)
distances %>%
group_by(from) %>%
top_n(-10, distance) %>% # select the closest 10 neighbors to each site
select(-distance) %>%
nest %>%
mutate(to = map(data, ~c(.) %>% pull)) %>%
pull(to)
distances %>%
group_by(from) %>%
top_n(-10, distance) %>% # select the closest 10 neighbors to each site
select(-distance) %>%
nest %>%
mutate(to = map(data, ~c(.) %>% unlist)) %>%
pull(to)
distances %>%
group_by(from) %>%
top_n(-10, distance) %>% # select the closest 10 neighbors to each site
select(-distance) %>%
nest %>%
mutate(to = map(data, ~c(.) %>% unlist))
paths <- distances %>%
group_by(from) %>%
top_n(-10, distance) %>% # select the closest 10 neighbors to each site
select(-distance) %>%
nest %>%
mutate(to = map(data, ~c(.) %>% unlist)) %>%
map2(from, to, ~shortestPath(conductance_c, as.matrix(pts[.x,], as.matrix(pts)[to,]), output = 'SpatialLines'))
paths <- distances %>%
group_by(from) %>%
top_n(-10, distance) %>% # select the closest 10 neighbors to each site
select(-distance) %>%
nest %>%
mutate(to = map(data, ~c(.) %>% unlist)) %>%
map2(from, to, ~shortestPath(conductance_c, as.matrix(pts[.x,], as.matrix(pts)[.y,]), output = 'SpatialLines'))
distances %>%
group_by(from) %>%
top_n(-10, distance) %>% # select the closest 10 neighbors to each site
select(-distance) %>%
nest %>%
mutate(to = map(data, ~c(.) %>% unlist))
paths <- distances %>%
group_by(from) %>%
top_n(-10, distance) %>% # select the closest 10 neighbors to each site
select(-distance) %>%
nest %>%
mutate(to = map(data, ~c(.) %>% unlist)) %>%
mutate(paths = map2(from, to, ~shortestPath(conductance_c, as.matrix(pts[.x,], as.matrix(pts)[.y,]), output = 'SpatialLines')))
paths <- distances %>%
group_by(from) %>%
top_n(-10, distance) %>% # select the closest 10 neighbors to each site
select(-distance) %>%
nest %>%
mutate(to = map(data, ~c(.) %>% unlist)) %>%
mutate(paths = map2(from, to, ~shortestPath(conductance_c, as.matrix(pts)[.x,], as.matrix(pts)[.y,], output = 'SpatialLines')))
paths
paths$paths
bind_rows(paths$paths)
do.call(bind, paths$paths)
plot(elev)
lines(do.call(bind, paths$paths))
