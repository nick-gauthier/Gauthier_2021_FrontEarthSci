---
title: "Untitled"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(reticulate)
```

Import python packages
```{r}
climate <- import('pyunicorn.climate', convert = F)
np <- import('numpy')
```

setablsih veriable names
```{r}
wind <- dict(list("time_min" = 0., "time_max" = 0., "lat_min" = 0, "lon_min" = 0,
          "lat_max" = 30, "lon_max" = 0))
data <- climate$ClimateData$Load(
    file_name = '/home/nick/Downloads/air.mon.mean.nc',
    observable_name = 'air',
    data_source = "ncep_ncar_reanalysis", 
    file_type = 'NetCDF',
    window = wind,  # selects the whole data set
    time_cycle = 12)
```
```{r}
net <- climate$TsonisClimateNetwork(data, threshold=0.5, winter_only = F)
```

```{r}
library(raster)
library(rasterVis)
library(tidyverse)
pdsi <- brick('~/Desktop/data/hackathon_PAGES2kv1/scpdsi_sfc_Amon_MCiters_ensemble_mean.nc') %>% rotate
levelplot(pdsi[[1:20]])
land.mask <- sum(pdsi != 0)
plot(land.mask)
pdsi <- mask(pdsi, land.mask, maskvalue = 0)
levelplot(pdsi[[1:20]])
writeRaster(pdsi, 'pdsi.nc', varname = 'pdsi', xname="lon",yname="lat", zname = 'time', overwrite = T)


pdsi
locations <- pdsi[[1]] %>% as.data.frame(xy = T, na.rm = T) %>% rownames_to_column() %>% mutate(rowname = as.numeric(rowname))
```





```{r}
library(tidygraph)
library(igraph)
library(ggraph)
read_csv('sim.txt')
net <- read_graph('net.ncol', directed = T) %>%
  as_tbl_graph %>%
  mutate(id = 1:1948) %>%
  left_join(locations, by = c('id' = 'rowname')) %>%
  filter(!is.na(x))

locs <- net %>% as_tibble
net %>%
  create_layout('manual', node.positions = locs[,2:3]) %>%
  ggraph() +
  borders('world') +
  #geom_polygon(aes(x = long, y = lat, group = region), data = states, color = 'black', fill = NA) +
  geom_edge_fan(alpha = .5) +
  #geom_node_point() +
  #geom_polygon(aes(x = long, y = lat, group = group), data = states, color = 'black', fill = NA) +
  coord_quickmap() +
  theme_void() +
  theme(legend.position="none")

ggsave('clim_net.pdf', width = 10, height = 10)
```

```{r}
library(maps)
library(maptools)
states <- map()
IDs <- sapply(strsplit(states$names, ":"), function(x) x[1])
states.ply <- map2SpatialPolygons(states, IDs=IDs)
```

#  Print script title
#

print "\n"
print "Tutorial on how to use climate"
print "-------------------------------"
print "\n"

#
#  Create a ClimateData object containing the data and print information
#

data = climate.ClimateData.Load(
    file_name=DATA_FILENAME, observable_name=OBSERVABLE_NAME,
    data_source=DATA_SOURCE, file_type=FILE_TYPE,
    window=WINDOW, time_cycle=TIME_CYCLE)

#  Print some information on the data set
print data

#
#  Create a MapPlots object to manage 2D-plotting on the sphere
#

#  Comment this if you are not using pyngl for plotting!!!
map_plots = climate.MapPlots(data.grid, DATA_SOURCE)

#
#  Generate climate network using various procedures
#

#  One of several alternative similarity measures and construction mechanisms
#  may be chosen here

#  Create a climate network based on Pearson correlation without lag and with
#  fixed threshold
net = climate.TsonisClimateNetwork(
    data, threshold=THRESHOLD, winter_only=WINTER_ONLY)
    
#  Create a climate network based on Pearson correlation without lag and with
#  fixed link density
# net = climate.TsonisClimateNetwork(
#     data, link_density=LINK_DENSITY, winter_only=WINTER_ONLY)

#  Create a climate network based on Spearman's rank order correlation without
#  lag and with fixed threshold
# net = climate.SpearmanClimateNetwork(
#     data, threshold=THRESHOLD, winter_only=WINTER_ONLY)

#  Create a climate network based on mutual information without lag and with
#  fixed threshold
# net = climate.MutualInfoClimateNetwork(
#    data, threshold=THRESHOLD, winter_only=WINTER_ONLY)

#
#  Some calculations
#

print "Link density:", net.link_density

#  Get degree
degree = net.degree()
#  Get closeness
closeness = net.closeness()
#  Get betweenness
betweenness = net.betweenness()
#  Get local clustering coefficient
clustering = net.local_clustering()
#  Get average link distance
ald = net.average_link_distance()
#  Get maximum link distance
mld = net.max_link_distance()

#
#  Save results to text file
#

#  Save the grid (mainly vertex coordinates) to text files
data.grid.save_txt(filename="grid.txt")

#  Save the degree sequence. Other measures may be saved similarly.
np.savetxt("degree.txt", degree)

#
#  Plotting
#

#  Comment everything below if you are not using pyngl for plotting!

#  Add network measures to the plotting queue
map_plots.add_dataset("Degree", degree)
map_plots.add_dataset("Closeness", closeness)
map_plots.add_dataset("Betweenness (log10)", np.log10(betweenness + 1))
map_plots.add_dataset("Clustering", clustering)
#map_plots.add_dataset("Average link distance", ald)
map_plots.add_dataset("Maximum link distance", mld)

#  Change the map projection
map_plots.resources.mpProjection = "Robinson"
map_plots.resources.mpCenterLonF = 0

#  Change the levels of contouring
map_plots.resources.cnLevelSelectionMode = "EqualSpacedLevels"
map_plots.resources.cnMaxLevelCount = 20

# map_plots.resources.cnRasterSmoothingOn = True
# map_plots.resources.cnFillMode = "AreaFill"

map_plots.generate_map_plots(file_name="climate_network_measures",
                             title_on=False, labels_on=True)
