---
title: "R Notebook"
output: html_notebook
---

Integrating network data and eofs


First import the SWSN attribute file. Use tidyverse packages for data munging.

Site coordinates are in UTM, so first use rgdal to reproject to LatLon.
```{r message = F, warning = F}
library(raster)
library(rasterVis)
library(tidyverse)
library(rgdal)

swsn.pts <- read_csv('Data/attributes_orig.csv') %>% 
  select(easting = EASTING, northing = NORTHING) %>%
  SpatialPoints(proj4string=CRS("+proj=utm +zone=12 +datum=WGS84")) %>%
  spTransform(CRS("+proj=longlat +datum=WGS84")) %>% 
  coordinates %>%
  data.frame
```

Now reimport the attribute file, select the relevant data, and combine with the reprojected site coordinates.
```{r message = F}
swsn.attr <- read_csv('Data/attributes_orig.csv') %>%
  dplyr::select(ID = SWSN_ID, site = SWSN_Site, macro = Macro, micro = Micro, size = P1room) %>%
  cbind(swsn.pts)
```

Now define a function to import the SWSN adjacency matrix for a given time step. This function imports the adjacency matrix and creates an igraph object. Then it adds attribute data from above to the graph object.
```{r message = F}
library(igraph)

readSWSN <- function(net){
  net.in <- read.csv(net, row.names = 1, check.names = F) %>% 
    as.matrix %>%
    graph_from_adjacency_matrix(mode = 'undirected', weighted = T, diag = F)
  
  ord <- match(V(net.in)$name, swsn.attr$site)

  V(net.in)$lon <- swsn.attr[ord, 6]
  V(net.in)$lat <- swsn.attr[ord, 7]
  V(net.in)$size <- swsn.attr[ord, 5]
  V(net.in)$region <- swsn.attr[ord, 3] %>% as.character
  
  return(net.in)
}
```

Use the function to import the network datasets.
```{r}
ad1200 <- readSWSN('Data/AD1200sim.csv')
ad1250 <- readSWSN('Data/AD1250sim.csv')
ad1300 <- readSWSN('Data/AD1300sim.csv')
ad1350 <- readSWSN('Data/AD1350sim.csv')
ad1400 <- readSWSN('Data/AD1400sim.csv')
```

Import eof data
```{r}
eof <- brick('Data/eof_all.nc')[[1:6]] %>% setNames(c('eof1', 'eof2', 'eof3', 'eof4', 'eof5', 'eof6'))
levelplot(eof, par.settings = RdBuTheme(), at = seq(-.03, .03, .003))
```
Import elevation too.
```{r}
elev <- raster('Data/swsn_NED_1.tif')
levelplot(elev, margin = F)
```
Also mean climate data.
```{r}
prcp.mean <- brick('Data/prec-sw.nc') %>% stackApply(.,indices = rep(1: (nlayers(.)/12), each = 12), fun = sum) %>% mean
levelplot(prcp.mean, margin = F, par.settings = PuOrTheme())
```

```{r}
temp.mean <- ((brick('Data/trefmnav-sw.nc') %>% mean) + (brick('Data/trefmnav-sw.nc') %>% mean)) / 2
levelplot(temp.mean)
```

```{r}
water.stress.mean <- brick('Data/water_stress.nc') %>% stackApply(.,indices = rep(1: (nlayers(.)/12), each = 12), fun = sum) %>% mean
levelplot(water.stress.mean)
plot(water.stress.mean, elev)
```


```{r}
ad1200.pts <- cbind(V(ad1200)$lon, V(ad1200)$lat)
eof.vals <- raster::extract(eof, ad1200.pts)
V(ad1200)$eof1 <- eof.vals[,1]
V(ad1200)$eof2 <- eof.vals[,2]
V(ad1200)$eof3 <- eof.vals[,3]
V(ad1200)$eof4 <- eof.vals[,4]
V(ad1200)$eof5 <- eof.vals[,5]
V(ad1200)$eof6 <- eof.vals[,6]

V(ad1200)$elev <- raster::extract(elev, ad1200.pts)
V(ad1200)$prcp <- raster::extract(prcp.mean, ad1200.pts)
V(ad1200)$temp <- raster::extract(temp.mean, ad1200.pts)
V(ad1200)$ws <- raster::extract(water.stress.mean, ad1200.pts)

el <- get.edgelist(ad1200)
E(ad1200)$eof1 <- abs(V(ad1200)[el[, 1]]$eof1 - V(ad1200)[el[, 2]]$eof1)
E(ad1200)$eof2 <- abs(V(ad1200)[el[, 1]]$eof2 - V(ad1200)[el[, 2]]$eof2)
E(ad1200)$eof3 <- abs(V(ad1200)[el[, 1]]$eof3 - V(ad1200)[el[, 2]]$eof3)
E(ad1200)$eof4 <- abs(V(ad1200)[el[, 1]]$eof4 - V(ad1200)[el[, 2]]$eof4)
E(ad1200)$eof5 <- abs(V(ad1200)[el[, 1]]$eof5 - V(ad1200)[el[, 2]]$eof5)
E(ad1200)$eof6 <- abs(V(ad1200)[el[, 1]]$eof6 - V(ad1200)[el[, 2]]$eof6)

# now binary
E(ad1200)$eof1.b <- factor(sign(V(ad1200)[el[, 1]]$eof1) != sign(V(ad1200)[el[, 2]]$eof1))
E(ad1200)$eof2.b <- factor(sign(V(ad1200)[el[, 1]]$eof2) != sign(V(ad1200)[el[, 2]]$eof2))
E(ad1200)$eof3.b <- factor(sign(V(ad1200)[el[, 1]]$eof3) != sign(V(ad1200)[el[, 2]]$eof3))
E(ad1200)$eof4.b <- factor(sign(V(ad1200)[el[, 1]]$eof4) != sign(V(ad1200)[el[, 2]]$eof4))
E(ad1200)$eof5.b <- factor(sign(V(ad1200)[el[, 1]]$eof5) != sign(V(ad1200)[el[, 2]]$eof5))
E(ad1200)$eof6.b <- factor(sign(V(ad1200)[el[, 1]]$eof6) != sign(V(ad1200)[el[, 2]]$eof6))

E(ad1200)$from_lat <- V(ad1200)[el[, 1]]$lat
E(ad1200)$from_lon <- V(ad1200)[el[, 1]]$lon
E(ad1200)$to_lat <- V(ad1200)[el[, 2]]$lat
E(ad1200)$to_lon <- V(ad1200)[el[, 2]]$lon


E(ad1200)$size.prod <- V(ad1200)[el[, 1]]$size * V(ad1200)[el[, 2]]$size


E(ad1200)$elev <- abs(V(ad1200)[el[, 1]]$elev - V(ad1200)[el[, 2]]$elev)
E(ad1200)$prcp <- abs(V(ad1200)[el[, 1]]$prcp - V(ad1200)[el[, 2]]$prcp)
E(ad1200)$temp <- abs(V(ad1200)[el[, 1]]$temp - V(ad1200)[el[, 2]]$temp)
E(ad1200)$water.stress <- abs(V(ad1200)[el[, 1]]$ws - V(ad1200)[el[, 2]]$ws)


dat <- igraph::as_data_frame(ad1200)
dat
```



```{r}
library(geosphere)
dat$dist <- distHaversine(cbind(dat$from_lon, dat$from_lat), cbind(dat$to_lon, dat$to_lat))
```

LCP distance matrix
```{r}
library(gdistance)
```

```{r}
elev.agg <- raster('~/Data/NED/swsn_NED_1.tif') %>% aggregate(fact = 100)
```

```{r}
altDiff <- function(x){x[2] - x[1]}
hd <- transition(elev.agg, altDiff, 8, symm=FALSE)
slope <- geoCorrection(hd, type = 'c')

adj <- adjacent(elev.agg, cells=1:ncell(elev.agg), pairs=TRUE, directions=8)
speed <- slope
speed[adj] <- 6 * exp(-3.5 * abs(slope[adj] + 0.05))
Conductance <- geoCorrection(speed, type = 'c')

lcp1 <- costDistance(Conductance, cbind(dat$from_lon, dat$from_lat), cbind(dat$to_lon, dat$to_lat)) %>% diag
lcp2 <- costDistance(Conductance, cbind(dat$to_lon, dat$to_lat), cbind(dat$from_lon, dat$from_lat)) %>% diag
dat$lcp <- lcp1 + lcp2
```

```{r}
qplot(lcp, weight, data = dat, alpha = I(.1), geom = 'point') +
  geom_smooth() +
  theme_minimal()
```


```{r}
qplot(x = dat$dist, geom = 'density')
qplot(x = dat$lcp, geom = 'density')
qplot(dist, lcp, data = dat, geom = 'point') +
  geom_smooth() +
  theme_minimal()
```

Let's start with just the environmental covariates
```{r}
library(mgcv)
library(broom)
mod1 <- gam(weight ~ s(lcp, bs = 'cr') +
              s(ws, bs = 'cr') +
              s(elev, bs = 'cr') +
              s(prcp, bs = 'cr') +
              s(temp, bs = 'cr') +
              s(eof2, bs = 'cr') + 
              s(eof3, bs = 'cr') + 
              s(eof4, bs = 'cr') + 
              s(eof5, bs = 'cr') + 
              s(eof6, bs = 'cr'),
            family=betar(link="logit"),
            method = 'REML', select = T, data = dat)
plot(mod1, pages = 1) 
summary(mod1)
gam.check(mod1)
glance(mod1)
```
```{r}
mod2 <- gam(weight ~ s(lcp, bs = 'cr') +
              s(ws, bs = 'cr') +
              s(elev, bs = 'cr') +
              s(eof3, bs = 'cr') + 
              s(eof4, bs = 'cr'),
            family=betar(link="logit"),
            method = 'REML', data = dat)
plot(mod2, pages = 1)
glance(mod2)
```
```{r}
mod3 <- gam(weight ~ eof2.b +
              s(lcp, bs = 'cr') +
              s(w, bs = 'cr') +
              s(elev, bs = 'cr') +
              s(eof3, bs = 'cr') + 
              s(eof4, bs = 'cr'),
            family=betar(link="logit"),
            method = 'REML', data = dat)
plot(mod3, pages = 1)
glance(mod3)
summary(mod3)
```

```{r}
mod4 <- gam(weight ~ eof2.b + eof3.b + eof4.b +
              s(lcp, bs = 'cr') +
              s(ws, bs = 'cr') +
              s(elev, bs = 'cr') +
              s(eof3, by = eof3.b) + 
              s(eof4, by = eof4.b),
            family=betar(link="logit"),
            method = 'REML', data = dat)
plot(mod4, pages = 1)
glance(mod4)
```
```{r}
dat$eof2.b %>% class
c(T,F,T) %>% factor
eof2.b
```

```{r}
mod1 <- gam(weight ~ s(lcp, bs = 'cr'),
            family=betar(link="logit"),
            method = 'REML', select = T, data = dat)

mod2 <- gam(weight ~ s(lcp, bs = 'cr') +
              s(elev, bs = 'cr'),
            family=betar(link="logit"),
            method = 'REML', select = T, data = dat)

mod3 <- gam(weight ~ s(lcp, bs = 'cr') +
              s(prcp, bs = 'cr') +
              s(temp, bs = 'cr'),
            family=betar(link="logit"),
            method = 'REML', select = T, data = dat)

mod4 <- gam(weight ~ s(lcp, bs = 'cr') +
              s(elev, bs = 'cr') +
              s(prcp, bs = 'cr') +
              s(temp, bs = 'cr'),
            family=betar(link="logit"),
            method = 'REML', select = T, data = dat)

```

```{r}
library(broom)
library(tidyverse)
```

Distance alone explains 50% of the variance
```{r}
summary(mod1)
bind_rows(glance(mod1), glance(mod2), glance(mod3), glance(mod4))

summary(mod1)
gam.check(mod4)
```


Size doesn't matter
```{r}
mod5 <- gam(weight ~ s(lcp, bs = 'cr') +
              s(size.prod, bs = 'cr'),
            family=betar(link="logit"),
            method = 'REML', select = T, data = dat)
glance(mod5)
```

```{r}
mod6 <- gam(weight ~ s(lcp, bs = 'cr') +
              s(eof2, bs = 'cr') + 
              s(eof3, bs = 'cr') + 
              s(eof4, bs = 'cr') + 
              s(eof5, bs = 'cr') + 
              s(eof6, bs = 'cr'),
            family=betar(link="logit"),
            method = 'REML', select = T, data = dat)

mod4 <- gam(weight ~ s(lcp, bs = 'cr') +
              s(size.prod, bs = 'cr') + 
              s(eof2, bs = 'cr') + 
              s(eof3, bs = 'cr') + 
              s(eof4, bs = 'cr') + 
              s(eof5, bs = 'cr') + 
              s(eof6, bs = 'cr'),
            family=betar(link="logit"),
            method = 'REML', select = T, data = dat)

mod5 <- gam(weight ~ s(lcp, bs = 'cr') +
              s(eof2, bs = 'cr') + 
              s(eof3, bs = 'cr') + 
              s(eof4, bs = 'cr') + 
              s(eof5, bs = 'cr') + 
              s(eof6, bs = 'cr'),
            family=betar(link="logit"),
            method = 'REML', select = T, data = dat)



```
Should we include or exclude the factors?
```{r}
mod8 <- gam(weight ~ s(lcp, bs = 'cr') +
              s(eof2, bs = 'cr') + 
              s(eof3, bs = 'cr') + 
              s(eof4, bs = 'cr') + 
              s(eof5, bs = 'cr') + 
              s(eof6, bs = 'cr'),
            family=betar(link="logit"),
            method = 'REML', select = T, data = dat)

mod9 <- gam(weight ~ s(lcp, bs = 'cr') +
              s(eof2, by = eof2.b, bs = 'cr') + 
              s(eof3, by = eof3.b, bs = 'cr') + 
              s(eof4, by = eof4.b, bs = 'cr') + 
              s(eof5, by = eof5.b, bs = 'cr') + 
              s(eof6, by = eof6.b, bs = 'cr'),
            family=betar(link="logit"),
            method = 'REML', select = T, data = dat)

mod10 <- gam(weight ~ eof2.b + eof3.b + eof4.b + eof5.b + eof6.b +
              s(lcp, bs = 'cr') +
              s(eof2, by = eof2.b, bs = 'cr') + 
              s(eof3, by = eof3.b, bs = 'cr') + 
              s(eof4, by = eof4.b, bs = 'cr') + 
              s(eof5, by = eof5.b, bs = 'cr') + 
              s(eof6, by = eof6.b, bs = 'cr'),
            family=betar(link="logit"),
            method = 'REML', select = T, data = dat)
```

For mod 8, aic of -33156, 58.9% deviance explain, all terms significant but eof2 the least so
```{r}
summary(mod8)
glance(mod8)
tidy(mod8)
```
61.5% deviance AIC -34261, again most significant were 4 and 5 eofs
```{r}
summary(mod9)
glance(mod9)
tidy(mod9)
```
-34263, 51.5 devienance, factors for 4 5were ignsignifcant, 6 and 3 were kinda sign
```{r}
summary(mod10)
glance(mod10)
tidy(mod10)
plot(mod10)
```

so adding in the factor in tercepts doesnt change much because they get mostly swamped out. but interestingly 2 is kept in
so maybe whats important for two is whether you have any tie, regardless of how strong it is, across the monsoon boundary. the others are important only if far awya


now fit mod 11 getting rid of the insig factors
```{r}
mod11 <- gam(weight ~ eof2.b + eof3.b + eof6.b +
              s(lcp, bs = 'cr') +
              s(eof2, by = eof2.b, bs = 'cr') + 
              s(eof3, by = eof3.b, bs = 'cr') + 
              s(eof4, by = eof4.b, bs = 'cr') + 
              s(eof5, by = eof5.b, bs = 'cr') + 
              s(eof6, by = eof6.b, bs = 'cr'),
            family=betar(link="logit"),
            method = 'REML', select = T, data = dat)
```

Now a model with everything!
```{r}
mod11 <- gam(weight ~ eof2.b + eof3.b + eof4.b + eof5.b + eof6.b +
              s(lcp, bs = 'cr') +
              s(elev, bs = 'cr') +
              s(prcp, bs = 'cr') +
              s(temp, bs = 'cr') +
              s(size.prod, bs = 'cr') +
              s(eof2, by = eof2.b, bs = 'cr') + 
              s(eof3, by = eof3.b, bs = 'cr') + 
              s(eof4, by = eof4.b, bs = 'cr') + 
              s(eof5, by = eof5.b, bs = 'cr') + 
              s(eof6, by = eof6.b, bs = 'cr'),
            family=betar(link="logit"),
            method = 'REML', select = T, data = dat)

gam.check(mod11)
tidy(mod11)
glance(mod11)
plot(mod11, pages = 1, scale = -1)
summary(mod11)
```
should eliminate size and elev

as eof number increases, the number of across ties increase too
```{r}
dat$eof6.b %>% hist
```

```{r}
logit<-function(x) log(x/(1-x))
hist(logit(dat$weight))
```

```{r}
hist(dat$elev %>% log)
hist(dat$prcp %>% log)
hist(dat$eof2 %>% log)
hist(dat$temp %>% log)
hist(dat$lcp)
```

```{r}
mod12 <- gam(weight ~ eof2.b +
              s(lcp, bs = 'cr') +
              s(elev, bs = 'cr') +
              s(prcp, bs = 'cr') +
              s(temp, bs = 'cr') +
              s(eof2, bs = 'cr') + 
              s(eof3, bs = 'cr') + 
              s(eof4, bs = 'cr') + 
              s(eof5, bs = 'cr') + 
              s(eof6, bs = 'cr'),
            family=betar(link="logit"),
            method = 'REML', select = T, data = dat)
plot(mod12, pages = 1)
glance(mod12)
summary(mod12)
```
remove factor
```{r}
mod13 <- gam(weight ~ s(lcp, bs = 'cr') +
              s(elev, bs = 'cr') +
              s(prcp, bs = 'cr') +
              s(temp, bs = 'cr') +
              s(eof2, bs = 'cr') + 
              s(eof3, bs = 'cr') + 
              s(eof4, bs = 'cr') + 
              s(eof5, bs = 'cr') + 
              s(eof6, bs = 'cr'),
            family=betar(link="logit"),
            method = 'REML', select = T, data = dat)
```

```{r}
glance(mod13)
plot(mod12, pages = 1)
```


     
     
     
     
