---
title: "sw_networks"
author: "Nick Gauthier"
date: "June 1, 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Setup
Load the necessary packages.
```{r message = F}
library(raster)
library(tidyverse)
library(rgdal)
library(gdistance)
library(wql)
library(tidygraph)
library(ggraph)
library(mgcv)
```


## Empiricial Orthogonal Functions
First we estimate present and past climate patterns
Define a boundary box for the western US
```{r}
bbox_wus <- extent(c(-124, -105, 31, 41))
```

Import high resolution SPEI maps generated from prism data. Calculate the average summertime (JJA) SPEI value for each year.
```{r observation-import, warning = F, message=F}
spei_obs <- ((brick('Data/spei12_6_PRISM.nc') + 
              brick('Data/spei12_7_PRISM.nc') + 
              brick('Data/spei12_8_PRISM.nc')) / 3) %>%
  crop(bbox_wus) %>%
  `names<-`(1895:2017) %>%
  .[[2:105]]  # remove the first value becuase spei needs a year lag time to calculate. 
```

Import the reconstructed SPEI data.
```{r phyda-import}
spei_recon <- brick('Data/da_hydro_JunAug_r.1-2000_d.05-Jan-2018.nc', varname = 'spei_mn') %>%
   .[[1100:1999]] %>%
   rotate %>%
   crop(bbox_wus, snap = 'out')
```

Plotting out the time series of the reconstruction reveals no clear trend in the mean. It does, however, show a pattern of increasing variance over time, which is entirely a function of the changing number of proxies used in the data assimilaiton approach.
```{r echo = F}
spei_recon %>% 
  as.data.frame(xy = T, na.rm = T) %>%
  gather(year, value, 3:902) %>%
  mutate(year = str_sub(year, 2),
         year = as.numeric(year)) %>%
  ggplot(aes(year, value)) +
  geom_line(alpha = .1, aes(group = interaction(x, y))) +
  geom_smooth() +
  ggtitle('Standardized Precipitation-Evapotranspiration Index in the American Southwest',
          'June-August, 12 month lag') +
  theme_bw()
```

Look at the variances for the eofs of each field, to inform truncation. Let's retain the leading four modes from PHYDA
```{r echo = F}
spei_recon %>%
  as.data.frame(na.rm = T) %>%
  t %>%
  eofNum(scale. = F)
```
Repeat for the prism observations. Again, we'll retain the leading four modes.
```{r echo = F}
#this code is the same as the eofNum function above, but needs a slight adjustment here because that function assumes more time than spatial indices
eigs <- prcomp(t(as.data.frame(spei_obs, na.rm = T)), scale. = F)[["sdev"]]^2
eigs.pct <- 100 * eigs/sum(eigs)
eigs.lo <- eigs * (1 - sqrt(2/104))
eigs.hi <- eigs * (1 + sqrt(2/104))
cumvar <- round(cumsum(eigs.pct), 1)
p <- 104
d <- data.frame(rank = factor(1:p), eigs, eigs.lo, eigs.hi, 
        cumvar)
d <- within(d, cumvar.line <- eigs.hi + 0.02 * max(eigs.hi))
d <- d[1:min(p, 10), ]
ggplot(data = d, aes(x = rank, y = eigs)) + geom_errorbar(aes(x = rank, 
        ymin = eigs.lo, ymax = eigs.hi), width = 0.3) + geom_point(size = 3) + 
        geom_text(aes(x = rank, y = cumvar.line, label = cumvar), 
            size = 3, vjust = 0) + labs(list(x = "Rank", y = "Eigenvalue")) + 
        theme(panel.grid.minor = element_blank())
```
The standard errors on the above plots assume there is no autocorrelation. Check to see if that is indeed the case.
```{r echo = F}
spei_recon %>%
  as.data.frame(na.rm = T) %>%
  t %>%
  as_tibble %>%
  gather(key, value) %>%
  pull(value) %>%
  acf

spei_obs %>%
  as.data.frame(na.rm = T) %>%
  t %>%
  as_tibble %>%
  gather(key, value) %>%
  pull(value) %>%
  acf
```
It looks like there is some autocorrelaiton, will have to adjust in the future.


Now, calculate the eofs for both fields, retaining the 4 leading components in each case for rotation
```{r}
n_modes <- 4

obs_eof <- spei_obs %>%
  as.data.frame(na.rm = T) %>%
  t %>%
  eof(n_modes, scale. = F)

recon_eof <- spei_recon %>%
  as.data.frame(na.rm = T) %>%
  t %>%
  eof(n_modes, scale. = F)
```

```{r echo = F}
as.data.frame(spei_obs[[1]], xy = T, na.rm = T) %>% cbind(obs_eof$REOF) %>%
  select(-3) %>%
  gather(eof, value, 3:(n_modes + 2)) %>%
  ggplot(aes(x,y)) +
  geom_raster(aes(fill = value)) +
    scale_fill_distiller(palette = 'BrBG', direction = 1, limits = c(-1, 1)) +
  facet_wrap(~eof) +
  theme_void() +
  coord_quickmap()
```

```{r echo = F}
as.data.frame(spei_recon[[1]], xy = T, na.rm = T) %>% cbind(recon_eof$REOF) %>%
  select(-3) %>%
  gather(eof, value, 3:(n_modes+2)) %>%
  ggplot(aes(x,y)) +
  geom_raster(aes(fill = value)) +
    scale_fill_distiller(palette = 'Spectral', direction = 1, limits = c(-1, 1)) +
  facet_wrap(~eof) +
  theme_void() + 
  coord_quickmap()
```
Look at the correlations between the modes.
```{r message = F, echo = F}
amplitudes <- left_join(
  recon_eof$amplitude %>%
    .[797:900,] %>%
    as_tibble %>%
    mutate(year = 1896:1999) %>%
    gather(eof, recon, 1:n_modes),
  obs_eof$amplitude %>%
    as_tibble %>%
    mutate(year = 1896:1999) %>%
    gather(eof, obs, 1:n_modes))
```

```{r echo = F}
ggplot(amplitudes, aes(recon, obs)) +
  geom_point(aes(color = year)) +
  geom_smooth(method = 'lm') +
  scale_color_viridis() +
  facet_wrap(~eof) +
  ggtitle('Linear fits between observed and reconstructed amplitudes', '1896-1999') +
  theme_minimal() +
  coord_fixed()
```

Now let's fit these models in practice. First create a data frame of past amplitudes.
```{r}
past_amplitudes <- recon_eof$amplitude %>%
    as_tibble %>%
    mutate(year = 1100:1999) %>%
    gather(eof, recon, 1:n_modes) %>%
  group_by(eof) %>%
  nest(.key = 'recons')
```

```{r echo = F, eval F}
phyda <- ncdf4::nc_open('Data/da_hydro_JunAug_r.1-2000_d.05-Jan-2018.nc')
cor(ncdf4::ncvar_get(phyda, 'PacDelSST_mn')[1100:1999], recon_eof$amplitude[,1])
cor(ncdf4::ncvar_get(phyda, 'PacDelSST_mn')[1100:1999], recon_eof$amplitude[,2])
cor(ncdf4::ncvar_get(phyda, 'PacDelSST_mn')[1100:1999], recon_eof$amplitude[,3])
cor(ncdf4::ncvar_get(phyda, 'PacDelSST_mn')[1100:1999], recon_eof$amplitude[,4])

plot(ncdf4::ncvar_get(phyda, 'Pac130_mn')[1100:1999], recon_eof$amplitude[,2])
plot(ncdf4::ncvar_get(phyda, 'Pac130_mn')[1100:1999], recon_eof$amplitude[,3])
cor(ncdf4::ncvar_get(phyda, 'Pac160_mn')[1100:1999], recon_eof$amplitude[,2])
cor(ncdf4::ncvar_get(phyda, 'Pac160_mn')[1100:1999], recon_eof$amplitude[,3])
cor(ncdf4::ncvar_get(phyda, 'Pac160_mn')[1100:1999], recon_eof$amplitude[,4])
cor(ncdf4::ncvar_get(phyda, 'amo_mn')[1100:1999], recon_eof$amplitude[,2])
cor(ncdf4::ncvar_get(phyda, 'amo_mn')[1100:1999], recon_eof$amplitude[,3])
cor(ncdf4::ncvar_get(phyda, 'Atl_mn')[1100:1999], recon_eof$amplitude[,1])
cor(ncdf4::ncvar_get(phyda, 'Atl_mn')[1100:1999], recon_eof$amplitude[,2])
cor(ncdf4::ncvar_get(phyda, 'Atl_mn')[1100:1999], recon_eof$amplitude[,3])
cor(ncdf4::ncvar_get(phyda, 'EPac_mn')[1100:1999], recon_eof$amplitude[,4])
```

```{r message = F}
recon_amplitudes <- amplitudes %>%
  group_by(eof) %>%
  nest %>%
  mutate(mod = map(data, ~gam(obs ~ s(recon, bs = 'cr'), data = ., method = 'REML', select = T))) %>%
  left_join(past_amplitudes) %>%
  mutate(predictions = map2(mod, recons, ~predict(.x, .y, type = 'response')),
         predictions = map(predictions, ~.[1:400]),
         predictions = map(predictions, ~tibble(year = 1100:1499, amplitude = .)),
         predictions = map(predictions, ~mutate(., amp_smooth = zoo::rollmean(amplitude, k = 51, fill = NA)))) %>%
  select(eof, predictions) %>%
  unnest %>%
  mutate(period = floor((year/50)) * 50) 
```

```{r echo = F}
ggplot(recon_amplitudes, aes(year, amplitude, group = eof)) +
  geom_line(aes(color = eof), alpha = .7) +
  geom_line(aes(y = amp_smooth)) +
  scale_color_brewer(palette = 'Spectral') +
  facet_wrap(~eof) +
  theme_minimal()
```

```{r}
recon_amplitudes %>%
  filter(between(period, 1200, 1400)) %>%
  ggplot(aes(factor(period), amplitude)) +
  geom_boxplot() +
  geom_hline(yintercept = 0, color = 'red', linetype = 2) +
  scale_color_brewer(palette = 'Spectral') +
  facet_wrap(~eof) +
  theme_minimal()
```

## Data import and preprocessing
Import the node and edge datasets.
```{r message = F}
node_data <- read_csv('Data/attributes_orig.csv')
```

```{r}
swsn <- list.files('Data/Sim', full.names = T) %>%
  map(read.csv, row.names = 1, check.names = F) %>%
  map(as.matrix) %>%
  map(~replace(.x, .x==0, 999)) %>%
  map(as_tbl_graph) %>%
  map(activate, edges) %>%
  imap(~mutate(.x, time = .y)) %>%
  reduce(graph_join) %>%
  filter(!edge_is_loop()) %>%
  mutate(weight = if_else(weight == 999, 0, weight)) %>%
  rename(similarity = weight) %N>%
  left_join(node_data, by = c('name' = 'SWSN_Site'))
```

Create a separate spatial points object, storing the locations of the sites. Convert the coordinates from utm to lat lon, and add back to the original data
```{r}
pts <- swsn %>% 
  select(x = EASTING, y = NORTHING) %>%
  as_tibble %>%
  SpatialPoints(proj4string=CRS("+proj=utm +zone=12 +datum=NAD27")) %>%
  spTransform(CRS("+proj=longlat +datum=WGS84")) %>% 
  coordinates %>%
  data.frame

swsn <- swsn %>%
  mutate(lon = pts$x, 
         lat = pts$y) %E>%
  mutate(from_x = .N()$lon[from],
         from_y = .N()$lat[from],
         to_x = .N()$lon[to],
         to_y = .N()$lat[to],
         size_from = case_when(time == 1 ~ .N()$P1room[from],
                               time == 2 ~ .N()$P2room[from],
                               time == 3 ~ .N()$P3room[from],
                               time == 4 ~ .N()$P4room[from],
                               time == 5 ~ .N()$P5room[from]),
         size_to = case_when(time == 1 ~ .N()$P1room[to],
                             time == 2 ~ .N()$P2room[to],
                             time == 3 ~ .N()$P3room[to],
                             time == 4 ~ .N()$P4room[to],
                             time == 5 ~ .N()$P5room[to]))
```
Get state outlines.
```{r}
states <- maps::map('state', regions = c('arizona', 'new mexico'), fill = T, plot = F)
```

```{r echo = F}
swsn %E>%
  filter(similarity > .75) %>%
ggraph('manual', node.positions = pts) +
  geom_edge_link(aes(alpha = similarity, color = similarity)) +
  facet_edges(~time) +
  geom_polygon(data = states, aes(x = long, y = lat, group = region), color = 'black', fill = NA) +
  scale_edge_alpha() +
  coord_equal() +
  theme_graph()
```

## Least Cost Distances
```{r}
bbox <- extent(c(-113.5, -106.5, 31, 37.5))
elev <- raster('~/Downloads/SRTM_W_250m_TIF/SRTM_W_250m.tif') %>%
  crop(bbox)
```

```{r cache = T}
altDiff <- function(x){x[2] - x[1]}
hd <- transition(elev, altDiff, 8, symm = F)
cell.targets <- Which(!is.na(elev), cells = T)
adj <- adjacent(elev, cells = cell.targets, target = cell.targets, pairs = T, directions = 8)
slope <- geoCorrection(hd, type = 'c')
speed <- slope
speed[adj] <- 6 * exp(-3.5 * abs(slope[adj] + 0.05))
conductance <- geoCorrection(speed, type = 'c')
```

```{r echo = F, message = F, warning = F}
rm(hd, adj, slope, speed)
gc()
```

```{r echo = F}
plot(raster(conductance))
```

Calculate the least cost distance matrix between all sites and turn into a graph.
```{r cache = T}
distances <- swsn %N>%
  select(lon, lat) %>%
  as_tibble %>%
  as.matrix %>%
  costDistance(conductance, .) %>%
  as_tbl_graph %E>%
  rename(distance = weight) %>%
  as_tibble
```

```{r echo = F}
gc()
```


```{r}
reof_raster <- as.data.frame(spei_obs[[1]], xy = T, na.rm = T) %>%
  select(x:y) %>%
  cbind(obs_eof$REOF) %>%
  rasterFromXYZ %>%
  `crs<-`('+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0') %>% 
  crop(bbox)

test <- recon_amplitudes %>%
  filter(between(period, 1200, 1400)) %>%
  group_by(eof, period) %>% 
  summarise(amplitude = mean(amplitude))

eof_data <- swsn %N>%
  select(lon, lat) %>%
  as_tibble %>%
  raster::extract(reof_raster, ., df = T) %>%
  gather(eof, value, 2:5) %>%
  full_join(test) %>%
  mutate(key = paste(eof, period, sep = '_'),
            value = value * amplitude) %>%
  select(ID, key, value) %>%
  spread(key, value, -1)

swsn <- swsn %N>%
  mutate(ID = 1:n()) %>%
  left_join(eof_data) %E>%
  mutate(EOF1_from = case_when(time == 1 ~ .N()$EOF1_1200[from],
                               time == 2 ~ .N()$EOF1_1250[from],
                               time == 3 ~ .N()$EOF1_1300[from],
                               time == 4 ~ .N()$EOF1_1350[from],
                               time == 5 ~ .N()$EOF1_1400[from]),
         EOF1_to = case_when(time == 1 ~ .N()$EOF1_1200[to],
                             time == 2 ~ .N()$EOF1_1250[to],
                             time == 3 ~ .N()$EOF1_1300[to],
                             time == 4 ~ .N()$EOF1_1350[to],
                             time == 5 ~ .N()$EOF1_1400[to]),
         EOF2_from = case_when(time == 1 ~ .N()$EOF2_1200[from],
                               time == 2 ~ .N()$EOF2_1250[from],
                               time == 3 ~ .N()$EOF2_1300[from],
                               time == 4 ~ .N()$EOF2_1350[from],
                               time == 5 ~ .N()$EOF2_1400[from]),
         EOF2_to = case_when(time == 1 ~ .N()$EOF2_1200[to],
                             time == 2 ~ .N()$EOF2_1250[to],
                             time == 3 ~ .N()$EOF2_1300[to],
                             time == 4 ~ .N()$EOF2_1350[to],
                             time == 5 ~ .N()$EOF2_1400[to]),
         EOF3_from = case_when(time == 1 ~ .N()$EOF3_1200[from],
                               time == 2 ~ .N()$EOF3_1250[from],
                               time == 3 ~ .N()$EOF3_1300[from],
                               time == 4 ~ .N()$EOF3_1350[from],
                               time == 5 ~ .N()$EOF3_1400[from]),
         EOF3_to = case_when(time == 1 ~ .N()$EOF3_1200[to],
                             time == 2 ~ .N()$EOF3_1250[to],
                             time == 3 ~ .N()$EOF3_1300[to],
                             time == 4 ~ .N()$EOF3_1350[to],
                             time == 5 ~ .N()$EOF3_1400[to]),
         EOF4_from = case_when(time == 1 ~ .N()$EOF4_1200[from],
                               time == 2 ~ .N()$EOF4_1250[from],
                               time == 3 ~ .N()$EOF4_1300[from],
                               time == 4 ~ .N()$EOF4_1350[from],
                               time == 5 ~ .N()$EOF4_1400[from]),
         EOF4_to = case_when(time == 1 ~ .N()$EOF4_1200[to],
                             time == 2 ~ .N()$EOF4_1250[to],
                             time == 3 ~ .N()$EOF4_1300[to],
                             time == 4 ~ .N()$EOF4_1350[to],
                             time == 5 ~ .N()$EOF4_1400[to]))
```

## Model fitting
```{r}
dat <- swsn %E>%
  left_join(distances) %>%
  as_tibble %>%
  mutate(distance = replace_na(distance, 0)) %>%
  mutate(edge = as.factor(paste(from, to, sep = '-')))
```

```{r echo = F}
ggplot(dat, aes(distance, similarity)) +
  geom_point(alpha = .1) +
  geom_smooth() +
  theme_minimal()
dat %>% 
  mutate(group = paste(from, to, sep = '-')) %>%
ggplot(aes(time, similarity, group = group)) +
  geom_line(alpha = .1)
```

```{r}
mod1 <- bam(similarity ~ s(distance, bs = 'cr'),
            method = 'REML',
            family = betar(link = 'cloglog'),
            data = dat)

mod2 <- bam(similarity ~ s(distance, bs = 'cr') +
                         s(size_from, bs = 'cr') +
                         s(size_to, bs = 'cr'),
            method = 'REML',
            family = betar(link = 'cloglog'),
            data = dat)

mod3 <- bam(similarity ~ s(distance, bs = 'cr') +
              s(size_from, bs = 'cr') +
              s(size_to, bs = 'cr') +
            s(from_x, from_y, k = 30) +
            s(to_x, to_y, k = 30),
            method = 'REML',
            family = betar(link = 'cloglog'),
            data = dat)

mod3 <- bam(similarity ~ s(distance, bs = 'cr') +
            s(from_x, from_y) +
            s(to_x, to_y),
            method = 'REML',
            family = betar(link = 'cloglog'),
            data = dat)

mod2 <- gamm(similarity * 1000 ~ s(distance, bs = 'cr'),
            method = 'REML',
            family = poisson,
            correlation = corAR1(form = ~time|edge),
            data = dat)

plot(mod1);plot(mod2);plot(mod3)
AIC(mod1);AIC(mod2);AIC(mod3)
gam.check(mod3)
```

```{r}
test <- dat %>%
  mutate(resid = residuals(mod1, type = 'response')) %>%
  group_by(from, to) %>%
  arrange(time, .by_group = T) %>%
select(from, to, time, resid) %>%
  mutate(lag1 = lag(resid)) %>%
  filter(!is.na(lag1))
cor(test$resid, test$lag1)

acf(test[1:3,6], lag.max = 5)

mod2 <- dat %>% 
  group_by(from, to) %>% 
  arrange(time, .by_group = T) %>%
  mutate(test = if_else(row_number() == 1, T, F)) %>%
  bam(similarity ~ s(distance, bs = 'cr'),
            method = 'REML',
            family = betar(link = 'cloglog'),
            rho = .3,
            AR.start = test,
            data = .)

plot(mod2)
presidents

swsn %E>% filter(from == 1) %>% as_tibble %>% select(similarity) %>% pull %>% sum
```

```{r}
mod2 <- gam(weight ~ s(distance, bs = 'cr'),
            method = 'REML',
            select = T, 
            data = dat)
mod3 <- gam(weight ~ s(distance, bs = 'cr'),
            method = 'REML',
            family = gaussian(link = 'log'),
            select = T, 
            data = dat)
mod4 <- gam(weight * 1000 ~ s(distance, bs = 'cr'),
            method = 'REML',
            family = poisson,
            select = T, 
            data = dat)
plot(mod1); plot(mod2); plot(mod3); plot(mod4)
list(mod1,mod2,mod3, mod4) %>% map(summary)
list(mod1,mod2,mod3, mod4) %>% map(gam.check)
```

```{r}
mod5 <- gam(weight ~ s(distance, bs = 'cr') +
                     s(size_prod, bs = 'cr') +
                     ti(distance, size_prod), 
            method = 'REML',
            select = T, 
            family = betar(link = 'cloglog'),
            eps  = .0001,
            data = dat)
mod6 <- gam(weight ~ te(distance, size_prod), 
            method = 'REML',
            select = T, 
            family = betar(link = 'cloglog'),
            eps = .0001,
            data = dat)
mod7 <- gam(weight ~ te(distance, size_sum), 
            method = 'REML',
            select = T, 
            family = betar(link = 'cloglog'),
            eps = .0001,
            data = dat)
mod8 <- gam(weight ~ s(distance, bs = 'cr') +
                     s(size_sum, bs = 'cr') +
                     ti(distance, size_sum), 
            method = 'REML',
            select = T, 
            family = betar(link = 'cloglog'),
            eps  = .0001,
            data = dat)

plot(mod5, scheme = 1)
plot(mod6, scheme = 1)
plot(mod7, scheme = 1)
plot(mod8, scheme = 1)
summary(mod5);summary(mod6);summary(mod7)
gam.check(mod6)
dat %>% 
  pull(weight) %>%
  summary
```

```{r}
swsn %E>%
  mutate(resid = residuals(mod2, type = 'response')) %>%
  filter(resid > .25 | resid < -.25) %>%
  mutate(fac = if_else(resid > 0, 'pos', 'neg')) %>%
  ggraph('manual', node.positions = pts) +
  geom_edge_link(aes(alpha = abs(resid), color = resid)) +
  facet_graph(time ~ fac, col_type = 'edge') +
  geom_polygon(data = states, aes(x = long, y = lat, group = region), color = 'black', fill = NA) +
  scale_edge_colour_distiller(palette = 'RdBu', limits = c(-1,1)) +
  coord_equal() +
  theme_graph()
```

